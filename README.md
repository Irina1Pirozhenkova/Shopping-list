# Shopping-list
Проектирование и разработка мобильного клиент-серверного приложения «Умный спи-сок покупок», предназначенного для интеллектуального создания и синхронизации списков покупок (без прямой интеграции с API магазинов).
---
### 1 Описание бизнес-логики мобильного приложения
Диаграмма показывает, что при запуске приложение проверяет сессию: если пользователь авторизован, сразу открывается главное меню, иначе сначала выполняется вход или регистрация. В главном меню доступны три функции — просмотр, создание и удаление списков; операции создания и удаления оформлены как подпроцессы, после которых возвращают в меню. Выход из приложения через кнопку закрытия корректно завершает фоновые задачи и фиксирует окончание сессии.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81%D1%81%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B9.png
![image](https://github.com/user-attachments/assets/9d1af1e6-46b6-4f7c-9876-ac6290e607a2)

Следующая диаграмма иллюстрирует подпроцесс входа и регистрации: приложение запрашивает e-mail и пароль, проверяет наличие учётной записи и корректность пароля, а при отсутствии e-mail предлагает зарегистрироваться. После успешной валидации данные сохраняются на сервере, и пользователь получает подтверждение авторизации, а в случае ошибки (неверный пароль или дублирование e-mail) выводится уведомление с возможностью повторного ввода.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D0%B8.png
![image](https://github.com/user-attachments/assets/0debbc38-f854-4e2c-b005-da766198afe0)

Диаграмма показывает, как при открытии списка система загружает актуальные данные из базы, а пользователь может отметить товар купленным, изменить важность, добавить новую или удалить существующую позицию — при этом любые изменения сразу сохраняются и сопровождаются уведомлением об успешном обновлении.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D0%BF%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B0%20%D0%B8%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%BC%20%D0%BF%D0%BE%D0%BA%D1%83%D0%BF%D0%BE%D0%BA.png

![image](https://github.com/user-attachments/assets/3e5fdb10-9aa3-48a4-9421-4928ecdfd9b5)

Следующая диаграмма иллюстрирует, что при создании нового списка пользователь вводит его название и параметры товаров (наименование, количество, единица, приоритет) в пустом шаблоне, после чего данные автоматически сохраняются в базе, а приложение возвращает его в главное меню.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20%D0%BF%D0%BE%D0%BA%D1%83%D0%BF%D0%BE%D0%BA.png
![image](https://github.com/user-attachments/assets/64312a76-f456-4765-84a4-3ee02ab44790)

Диаграмма иллюстрирует подпроцесс настройки напоминаний: приложение показывает текущее состояние, позволяет установить или отключить напоминание через выбор даты и времени, сохраняет изменения в базе и возвращает пользователя в меню, а при срабатывании таймера отправляет push-уведомление.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8%20%D0%BD%D0%B0%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D0%BD%D0%B8%D1%8F%20%D1%83%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0.png
![image](https://github.com/user-attachments/assets/2d40845e-65a4-4c1b-8f0a-a558edfce4a8)

---
### 2 Основные функции приложения (в порядке убывания важности для пользователя):
## Основные функции

1. **Управление списками**  
   Создание, просмотр и удаление списков с любым названием — фундамент приложения.
2. **Управление товарами**  
   Добавление позиций с указанием количества, отметка «важное» (первые в списке), пометка «куплено» и удаление; все изменения сохраняются и сопровождаются кратким уведомлением.
3. **Хранение данных**  
   Локальная база данных обеспечивает мгновенную загрузку и сохранность списков и товаров между сессиями.
4. **Напоминания**  
   Установка или отключение таймеров с последующей отправкой push-уведомлений по расписанию.
5. **Поиск и фильтрация**  
   Моментальный поиск по названию, фильтрация по статусу («все», «важные», «куплено») и сортировка по приоритету или дате.
> **Примечание:** в текущей версии реализованы только эти функции. Дополнительные возможности (например, синхронизация между устройствами и совместная работа над списками) могут быть добавлены в будущих релизах.
6. **Синхронизация**: автоматический обмен правками между устройствами в онлайн/оффлайн-режиме, мгновенные обновления и уведомления соавторам.
---
### 3 Процесс синхронизации данных между клиентом и сервером на UML диаграммах
###### Диаграмма компонентов 
На компонентной диаграмме показано разделение на две основные подсистемы – Mobile Client и Server. В клиентской части пользовательский интерфейс (UI) взаимодействует с модулями AuthModule, ListManager, ItemManager и ReminderManager для регистра-ции/авторизации, управления списками, товарами и напоминаниями, при-чём все изменения сначала сохраняются в LocalDatabase, а SyncManager регулярно собирает их и через NetworkClient отправляет REST-запросы на сервер. На сервере API Gateway маршрутизирует запросы к соответ-ствующим сервисам (AuthService, ListService, ItemService, ReminderService и SyncService), которые выполняют операции над центральной базой дан-ных и возвращают результаты обратно клиенту. 
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Component%20Diagram.png
![image](https://github.com/user-attachments/assets/2988a7fb-dc1e-4f56-a870-b373df11f8d4)


###### Диаграмма активности
На диаграмме активности показан общий цикл синхро-низации между клиентом и сервером. Сначала на стороне клиента SyncManager собирает локальные изменения (CRUD-операции, отметки «куплено», напоминания) и проверяет, есть ли что отправить; если нет — сразу обновляет UI, иначе проверяет доступность сети. При онлайн-режиме пакет изменений уходит на сервер через REST-вызов /sync, где SyncService применяет эти операции к центральной базе и формирует спи-сок патчей новых данных. Клиент получает патчи, вносит их в локальную БД и лишь затем обновляет интерфейс. Если сеть недоступна, процесс ждет её восстановления (таймер или событие подключения) и повторяет отправ-ку без прерывания пользовательского потока.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Activity%20Diagram.png
![image](https://github.com/user-attachments/assets/445b21f5-a066-42ad-aff1-9da10ce9939e)


###### Диаграмма последовательности для добавления товаров
На диаграмме последовательностей показано, что после добавления товара в список SyncManager формирует операцию AddItem и передаёт её через NetworkClient на REST-эндпоинт /sync. API_Gateway пе-ренаправляет запрос в SyncService, которое выполняет INSERT в таблицу items и сразу же собирает все неприменённые операции (патчи). Сервер возвращает этот набор патчей клиенту, после чего SyncManager применяет их к локальной базе, гарантируя консистентность данных между устрой-ствами.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%BE%D0%B2%D0%B0%D1%80%D0%BE%D0%B2%20%D0%B2%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA.png
![image](https://github.com/user-attachments/assets/5a8ebb65-aecc-44f7-8c52-41265cbeacb2)


###### Диаграмма последовательности для изменения товара
На диаграмме показан процесс синхронизации измене-ния параметров товара: SyncManager формирует запрос с операцией UpdateItem (идентификатор товара и набор изменений) и передаёт его че-рез NetworkClient на REST-эндпоинт /sync. API_Gateway перенаправляет запрос в SyncService, которое выполняет в базе команду UPDATE items SET … WHERE id=… и затем запрашивает у таблицы операций все ещё не применённые патчи. Получив список изменений, сервер возвращает его клиенту, а SyncManager применяет эти патчи к локальной БД.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D0%BE%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20(%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%20%D0%B8%20%D0%BE%D1%82%D0%BC%D0%B5%D1%82%D0%B0%20%D0%BA%D1%83%D0%BF%D0%BB%D0%B5%D0%BD%D0%BE).png
![image](https://github.com/user-attachments/assets/d6a7c3e9-3c59-4fc1-9e1d-e2dd9a22ca93)

###### Диаграмма последовательности для создания списка
На диаграмме показан полный цикл синхронизации создания нового списка: клиентский SyncManager формирует операцию CreateList с данными списка и через NetworkClient отправляет её на эндпо-инт /sync. API_Gateway перенаправляет запрос в SyncService, где выпол-няется INSERT в таблицу списков, а затем сразу же собираются все непри-менённые операции (патчи) из журнала. После этого сервер возвращает клиенту набор патчей, содержащих как только что созданный список, так и любые изменения, сделанные другими устройствами, — и SyncManager применяет их к локальной БД.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0.png
![image](https://github.com/user-attachments/assets/e737b795-9b63-43bc-a7b1-21d5680dc701)

###### Диаграмма последовательности для удаления списка
В сценарии клиентский SyncManager формирует опе-рацию DeleteList, указывая идентификатор списка, и передаёт её через NetworkClient на эндпоинт /sync. Серверный SyncService получает запрос, выполняет в центральной базе команду DELETE FROM lists WHERE id=…, а затем сразу же извлекает все ещё не применённые операции (пат-чи) из журнала изменений. Ответом передаётся массив патчей, включаю-щий подтверждение удаления и любые другие актуальные обновления от соавторов или с других устройств. После получения ответа клиентский SyncManager применяет патчи к локальной базе, удаляя список и синхро-низируя состояние всех локальных данных.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0.png
![image](https://github.com/user-attachments/assets/b51e0928-59ec-427e-ad36-1056fe998be5)

###### API – методы
Для взаимодействия клиента с сервером используется REST-интерфейс:
**Аутентификация**  
- `POST /auth/register` — регистрация пользователя  
- `POST /auth/login` — вход и получение JWT-токена
**Управление списками**  
- `GET    /lists`                  — получить все списки  
- `POST   /lists`                  — создать новый список  
- `GET    /lists/{listId}`         — получить детали списка  
- `PUT    /lists/{listId}`         — обновить список  
- `DELETE /lists/{listId}`         — удалить список
**Управление товарами**  
- `GET    /lists/{listId}/items`             — все товары списка  
- `POST   /lists/{listId}/items`             — добавить товар  
- `PUT    /lists/{listId}/items/{itemId}`    — обновить товар  
- `PATCH  /lists/{listId}/items/{itemId}/purchase` — отметить «куплено»/«откупить»  
- `DELETE /lists/{listId}/items/{itemId}`    — удалить товар
**Напоминания**  
- `POST   /lists/{listId}/reminder` — установить или обновить напоминание  
- `DELETE /lists/{listId}/reminder` — отменить напоминание
**Синхронизация**  
- `POST /sync`  
  - В запросе: `{ clientId: "...", ops: [ { op, entity, data }, … ] }`  
  - В ответе: `{ patches: [ { entity, id, changes }, … ] }`

###### ER диаграмма сущностей
ER-диаграмма на рисунке 12 включает сущности User, ShoppingList, Item и Reminder: User связана с ShoppingList по «один-ко-многим» через user_id, ShoppingList объединяет множество Item по list_id и имеет един-ственное Reminder (отношение «один-к-одному»), а внешние ключи user_id и list_id гарантируют ссылочную целостность.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/ER%20%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9.png
![image](https://github.com/user-attachments/assets/715d41af-bd6e-4d02-9e77-904afff09310)
