# Shopping-list
Проектирование и разработка мобильного клиент-серверного приложения «Список покупок», предназначенного для интеллектуального создания и синхронизации списков покупок (без прямой интеграции с API магазинов).
---
### 1 Описание бизнес-логики мобильного приложения
Диаграмма показывает, что при запуске приложение проверяет сессию: если пользователь авторизован, сразу открывается главное меню, иначе сначала выполняется вход или регистрация. В главном меню доступны три функции — просмотр, создание и удаление списков; операции создания и удаления оформлены как подпроцессы, после которых возвращают в меню. Выход из приложения через кнопку закрытия корректно завершает фоновые задачи и фиксирует окончание сессии.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%91%D0%B8%D0%B7%D0%BD%D0%B5%D1%81%D1%81%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D0%B9.png
![image](https://github.com/user-attachments/assets/9d1af1e6-46b6-4f7c-9876-ac6290e607a2)

Следующая диаграмма иллюстрирует подпроцесс входа и регистрации: приложение запрашивает e-mail и пароль, проверяет наличие учётной записи и корректность пароля, а при отсутствии e-mail предлагает зарегистрироваться. После успешной валидации данные сохраняются на сервере, и пользователь получает подтверждение авторизации, а в случае ошибки (неверный пароль или дублирование e-mail) выводится уведомление с возможностью повторного ввода.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D0%B8.png
![image](https://github.com/user-attachments/assets/0debbc38-f854-4e2c-b005-da766198afe0)

Диаграмма показывает, как при открытии списка система загружает актуальные данные из базы, а пользователь может отметить товар купленным, изменить важность, добавить новую или удалить существующую позицию — при этом любые изменения сразу сохраняются и сопровождаются уведомлением об успешном обновлении.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D0%BF%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B0%20%D0%B8%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%BC%20%D0%BF%D0%BE%D0%BA%D1%83%D0%BF%D0%BE%D0%BA.png

![image](https://github.com/user-attachments/assets/3e5fdb10-9aa3-48a4-9421-4928ecdfd9b5)

Следующая диаграмма иллюстрирует, что при создании нового списка пользователь вводит его название и параметры товаров (наименование, количество, единица, приоритет) в пустом шаблоне, после чего данные автоматически сохраняются в базе, а приложение возвращает его в главное меню.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20%D0%BF%D0%BE%D0%BA%D1%83%D0%BF%D0%BE%D0%BA.png
![image](https://github.com/user-attachments/assets/64312a76-f456-4765-84a4-3ee02ab44790)

Диаграмма иллюстрирует подпроцесс настройки напоминаний: приложение показывает текущее состояние, позволяет установить или отключить напоминание через выбор даты и времени, сохраняет изменения в базе и возвращает пользователя в меню, а при срабатывании таймера отправляет push-уведомление.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%20%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8%20%D0%BD%D0%B0%D0%BF%D0%BE%D0%BC%D0%B8%D0%BD%D0%B0%D0%BD%D0%B8%D1%8F%20%D1%83%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0.png
![image](https://github.com/user-attachments/assets/2d40845e-65a4-4c1b-8f0a-a558edfce4a8)

---
### 2 Основные функции приложения (в порядке убывания важности для пользователя):
## Основные функции

1. **Управление списками**  
   Создание, просмотр и удаление списков с любым названием — фундамент приложения.
2. **Управление товарами**  
   Добавление позиций с указанием количества, отметка «важное» (первые в списке), пометка «куплено» и удаление; все изменения сохраняются и сопровождаются кратким уведомлением.
3. **Хранение данных**  
   Локальная база данных обеспечивает мгновенную загрузку и сохранность списков и товаров между сессиями.
4. **Напоминания**  
   Установка или отключение таймеров с последующей отправкой push-уведомлений по расписанию.
5. **Поиск и фильтрация**  
   Моментальный поиск по названию, фильтрация по статусу («все», «важные», «куплено») и сортировка по приоритету или дате.
> **Примечание:** в текущей версии реализованы только эти функции. Дополнительные возможности (например, синхронизация между устройствами и совместная работа над списками) могут быть добавлены в будущих релизах.
6. **Синхронизация**: автоматический обмен правками между устройствами в онлайн/оффлайн-режиме, мгновенные обновления и уведомления соавторам.
---
### 3 Процесс синхронизации данных между клиентом и сервером на UML диаграммах
###### Диаграмма компонентов 
На компонентной диаграмме показано разделение на две основные подсистемы – Mobile Client и Server. В клиентской части пользовательский интерфейс (UI) взаимодействует с модулями AuthModule, ListManager, ItemManager и ReminderManager для регистра-ции/авторизации, управления списками, товарами и напоминаниями, при-чём все изменения сначала сохраняются в LocalDatabase, а SyncManager регулярно собирает их и через NetworkClient отправляет REST-запросы на сервер. На сервере API Gateway маршрутизирует запросы к соответ-ствующим сервисам (AuthService, ListService, ItemService, ReminderService и SyncService), которые выполняют операции над центральной базой дан-ных и возвращают результаты обратно клиенту. 
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Component%20Diagram.png
![image](https://github.com/user-attachments/assets/2988a7fb-dc1e-4f56-a870-b373df11f8d4)


###### Диаграмма активности
На диаграмме активности показан общий цикл синхро-низации между клиентом и сервером. Сначала на стороне клиента SyncManager собирает локальные изменения (CRUD-операции, отметки «куплено», напоминания) и проверяет, есть ли что отправить; если нет — сразу обновляет UI, иначе проверяет доступность сети. При онлайн-режиме пакет изменений уходит на сервер через REST-вызов /sync, где SyncService применяет эти операции к центральной базе и формирует спи-сок патчей новых данных. Клиент получает патчи, вносит их в локальную БД и лишь затем обновляет интерфейс. Если сеть недоступна, процесс ждет её восстановления (таймер или событие подключения) и повторяет отправ-ку без прерывания пользовательского потока.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Activity%20Diagram.png
![image](https://github.com/user-attachments/assets/445b21f5-a066-42ad-aff1-9da10ce9939e)


###### Диаграмма последовательности для добавления товаров
На диаграмме последовательностей показано, что после добавления товара в список SyncManager формирует операцию AddItem и передаёт её через NetworkClient на REST-эндпоинт /sync. API_Gateway пе-ренаправляет запрос в SyncService, которое выполняет INSERT в таблицу items и сразу же собирает все неприменённые операции (патчи). Сервер возвращает этот набор патчей клиенту, после чего SyncManager применяет их к локальной базе, гарантируя консистентность данных между устрой-ствами.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%82%D0%BE%D0%B2%D0%B0%D1%80%D0%BE%D0%B2%20%D0%B2%20%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA.png
![image](https://github.com/user-attachments/assets/5a8ebb65-aecc-44f7-8c52-41265cbeacb2)


###### Диаграмма последовательности для изменения товара
На диаграмме показан процесс синхронизации измене-ния параметров товара: SyncManager формирует запрос с операцией UpdateItem (идентификатор товара и набор изменений) и передаёт его че-рез NetworkClient на REST-эндпоинт /sync. API_Gateway перенаправляет запрос в SyncService, которое выполняет в базе команду UPDATE items SET … WHERE id=… и затем запрашивает у таблицы операций все ещё не применённые патчи. Получив список изменений, сервер возвращает его клиенту, а SyncManager применяет эти патчи к локальной БД.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D0%BE%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%20(%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%20%D0%B8%20%D0%BE%D1%82%D0%BC%D0%B5%D1%82%D0%B0%20%D0%BA%D1%83%D0%BF%D0%BB%D0%B5%D0%BD%D0%BE).png
![image](https://github.com/user-attachments/assets/d6a7c3e9-3c59-4fc1-9e1d-e2dd9a22ca93)

###### Диаграмма последовательности для создания списка
На диаграмме показан полный цикл синхронизации создания нового списка: клиентский SyncManager формирует операцию CreateList с данными списка и через NetworkClient отправляет её на эндпо-инт /sync. API_Gateway перенаправляет запрос в SyncService, где выпол-няется INSERT в таблицу списков, а затем сразу же собираются все непри-менённые операции (патчи) из журнала. После этого сервер возвращает клиенту набор патчей, содержащих как только что созданный список, так и любые изменения, сделанные другими устройствами, — и SyncManager применяет их к локальной БД.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0.png
![image](https://github.com/user-attachments/assets/e737b795-9b63-43bc-a7b1-21d5680dc701)

###### Диаграмма последовательности для удаления списка
В сценарии клиентский SyncManager формирует опе-рацию DeleteList, указывая идентификатор списка, и передаёт её через NetworkClient на эндпоинт /sync. Серверный SyncService получает запрос, выполняет в центральной базе команду DELETE FROM lists WHERE id=…, а затем сразу же извлекает все ещё не применённые операции (пат-чи) из журнала изменений. Ответом передаётся массив патчей, включаю-щий подтверждение удаления и любые другие актуальные обновления от соавторов или с других устройств. После получения ответа клиентский SyncManager применяет патчи к локальной базе, удаляя список и синхро-низируя состояние всех локальных данных.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0.png
![image](https://github.com/user-attachments/assets/b51e0928-59ec-427e-ad36-1056fe998be5)

###### API – методы
Для взаимодействия клиента с сервером используется REST-интерфейс:
**Аутентификация**  
- `POST /auth/register` — регистрация пользователя  
- `POST /auth/login` — вход и получение JWT-токена
**Управление списками**  
- `GET    /lists`                  — получить все списки  
- `POST   /lists`                  — создать новый список  
- `GET    /lists/{listId}`         — получить детали списка  
- `PUT    /lists/{listId}`         — обновить список  
- `DELETE /lists/{listId}`         — удалить список
**Управление товарами**  
- `GET    /lists/{listId}/items`             — все товары списка  
- `POST   /lists/{listId}/items`             — добавить товар  
- `PUT    /lists/{listId}/items/{itemId}`    — обновить товар  
- `PATCH  /lists/{listId}/items/{itemId}/purchase` — отметить «куплено»/«откупить»  
- `DELETE /lists/{listId}/items/{itemId}`    — удалить товар
**Напоминания**  
- `POST   /lists/{listId}/reminder` — установить или обновить напоминание  
- `DELETE /lists/{listId}/reminder` — отменить напоминание
**Синхронизация**  
- `POST /sync`  
  - В запросе: `{ clientId: "...", ops: [ { op, entity, data }, … ] }`  
  - В ответе: `{ patches: [ { entity, id, changes }, … ] }`

###### ER диаграмма сущностей
ER-диаграмма на рисунке 12 включает сущности User, ShoppingList, Item и Reminder: User связана с ShoppingList по «один-ко-многим» через user_id, ShoppingList объединяет множество Item по list_id и имеет един-ственное Reminder (отношение «один-к-одному»), а внешние ключи user_id и list_id гарантируют ссылочную целостность.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/ER%20%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D1%81%D1%83%D1%89%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B9.png

![image](https://github.com/user-attachments/assets/715d41af-bd6e-4d02-9e77-904afff09310)

---
### 4 Прототип экрана мобильного приложения
На макете экрана списка покупок в шапке слева распо-ложена кнопка «Назад», по центру — название списка («Продукты на ужин»), а справа — индикатор активного напоминания. Под заголовком — большая кнопка «Добавить товар», открывающая форму ввода нового пункта. Каждый элемент списка представлен чекбоксом для отметки «куп-лено», названием товара и иконкой «звезда» для приоритетных позиций или пустым квадратом, а справа — меню действий (удалить, пометить купленным, изменить приоритет). Внизу размещена упрощённая навига-ция с двумя вкладками: «Главная» (текущий список) и «Списки» (обзор всех списков).
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0.jpg

![image](https://github.com/user-attachments/assets/b9a3ae50-de99-493c-a400-d8f0b190dc7f)

Ссылка на проект https://www.figma.com/design/gcmdOdZ1OfoNi9Rdw7FXBT/Untitled?node-id=0-1&t=JuhITtGZmJDlOGjw-0

---
### 5 Подробное описание функции покупки товара
###### Текстовое описание функции
Когда пользователь на экране списка нажимает чекбокс или выбирает «Отметить как куплено», приложение через модуль `ItemManager` моментально устанавливает в локальной базе данных у соответствующего товара флаг `purchased = true` и сразу отражает это в интерфейсе, перечёркивая название позиции. Одновременно операция попадает в очередь `SyncManager` для последующей передачи на сервер, где через единый эндпоинт `POST /sync` выполняется команда `UpdateItem` с параметром `{ "purchased": true }`, что обеспечивает мгновенную реакцию UI и гарантирует надёжную фиксацию статуса покупки.

###### Процесс хранения информации о покупке
В клиентском приложении данные о статусе покупки сохраняются в таблице `items` локальной базы данных (`LocalDatabase`), где булево поле `purchased` отражает факт совершения покупки, а сама операция добавляется в очередь синхронизации для офлайн-режима. На сервере `SyncService` выполняет аналогичное обновление центральной таблицы `items` и записывает информацию об операции в журнал `operations`, чтобы другие клиенты могли получить обновления (патчи) и поддерживать целостность данных между всеми экземплярами приложения.

###### UML диаграмма последовательности
На диаграмме показан полный цикл пометки товара как «куплено»: пользовательский UI вызывает ItemManager.markPurchased, который сразу обновляет локальную таблицу items и ставит задачу в оче-редь SyncManager. SyncManager по таймеру шлёт через NetworkClient за-прос POST /sync с операцией UpdateItem, SyncService на сервере выполня-ет UPDATE items SET purchased=true, собирает новые патчи и возвращает их клиенту. После получения клиент применяет патчи к LocalDatabase, обеспечивая актуальность данных на всех устройствах.
Ссылка на изображение https://github.com/Irina1Pirozhenkova/Shopping-list/blob/main/Sequence%20Diagram%20%D0%B4%D0%BB%D1%8F%20%D0%BE%D1%82%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8%20%D0%BF%D0%BE%D0%BA%D1%83%D0%BF%D0%BA%D0%B8%20%D1%82%D0%BE%D0%B2%D0%B0%D1%80%D0%B0.png
![image](https://github.com/user-attachments/assets/9c8ee1c4-07ea-41a6-abe9-867ba154b836)

###### API-метод
Этот эндпоинт устанавливает или снимает отметку «куплено» у товара и сразу возвращает подтверждение с актуальным статусом.
`PATCH /lists/{listId}/items/{itemId}/purchase`
- **Request**  
  ```json
  { "purchased": true|false }
{ "id": "<itemId>", "purchased": true|false }

---
### 6 Сложности разработки и вопросы заказчику
###### Основные сложности разработки:
1.	Offline-first и синхронизация: реализация надёжной очереди локальных операций и механизма разрешения конфликтов (например, «последний записавшийся выигрывает» или ручного выбора) требует ак-куратной архитектуры и тщательного тестирования.
2.	Уведомления и напоминания: разные версии ОС и ограничения фоновых задач усложняют стабильную работу таймеров и push-уведомлений на Android и iOS.
3.	Масштабируемость бэкенда: при росте числа списков и пользо-вателей нужно продумать эффективное хранение патчей, маршрутизацию /sync-запросов и балансировку нагрузки, чтобы не допустить деградации производительности.
###### Вопросы к заказчику:
1. Нужны ли тонкие права доступа внутри списков (например, «только чтение» vs «редактирование» для разных участников)?
2. Требуется ли шифрование данных на стороне клиента и сервера (например, для соответствия GDPR или корпоративным политикам без-опасности)?
3. Каковы ограничения по задержке синхронизации и количеству од-новременно подключённых устройств для одного списка (SLA, допусти-мые тайм-ауты)?

---
### 7 SQL – запросы для заданных таблиц
1. **Общая стоимость книг для каждого автора (по убыванию)**  
   ```sql
   SELECT
     a.AuthorName,
     SUM(b.Price) AS TotalPrice
   FROM Authors a
   JOIN Books b
     ON b.AuthorId = a.Id
   GROUP BY a.AuthorName
   ORDER BY TotalPrice DESC;
2. **Авторы с общей стоимостью книг > 1500**
```sql
SELECT
  a.AuthorName,
  SUM(b.Price) AS TotalPrice
FROM Authors a
JOIN Books b
  ON b.AuthorId = a.Id
GROUP BY a.AuthorName
HAVING SUM(b.Price) > 1500
ORDER BY TotalPrice DESC;

3. **Авторы и количество их книг**  
   ```sql
SELECT
  a.AuthorName,
  COUNT(*) AS BookCount
FROM Authors a
JOIN Books b
  ON b.AuthorId = a.Id
GROUP BY a.AuthorName
ORDER BY BookCount DESC;

4. **Авторы без книг**  
   ```sql
SELECT
  a.AuthorName
FROM Authors a
WHERE NOT EXISTS (
  SELECT 1
  FROM Books b
  WHERE b.AuthorId = a.Id
);
